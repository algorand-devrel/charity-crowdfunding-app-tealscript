"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigningAccount = exports.MultisigAccount = exports.DISPENSER_ACCOUNT = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
/**
 * The account name identifier used for fund dispensing in test environments
 */
exports.DISPENSER_ACCOUNT = 'DISPENSER';
/** Account wrapper that supports partial or full multisig signing. */
class MultisigAccount {
    _params;
    _signingAccounts;
    _addr;
    _signer;
    /** The parameters for the multisig account */
    get params() {
        return this._params;
    }
    /** The list of accounts that are present to sign */
    get signingAccounts() {
        return this._signingAccounts;
    }
    /** The address of the multisig account */
    get addr() {
        return this._addr;
    }
    get signer() {
        return this._signer;
    }
    constructor(multisigParams, signingAccounts) {
        this._params = multisigParams;
        this._signingAccounts = signingAccounts;
        this._addr = algosdk_1.default.multisigAddress(multisigParams);
        this._signer = algosdk_1.default.makeMultiSigAccountTransactionSigner(multisigParams, signingAccounts.map((a) => a.sk));
    }
    /**
     * Sign the given transaction
     * @param transaction Either a transaction object or a raw, partially signed transaction
     * @returns The transaction signed by the present signers
     */
    sign(transaction) {
        let signedTxn = 'from' in transaction ? undefined : transaction;
        for (const signer of this._signingAccounts) {
            if (signedTxn) {
                signedTxn = algosdk_1.default.appendSignMultisigTransaction(signedTxn, this._params, signer.sk).blob;
            }
            else {
                signedTxn = algosdk_1.default.signMultisigTransaction(transaction, this._params, signer.sk).blob;
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return signedTxn;
    }
}
exports.MultisigAccount = MultisigAccount;
/** Account wrapper that supports a rekeyed account */
class SigningAccount {
    _account;
    _signer;
    _sender;
    /**
     * Algorand address of the sender
     */
    get addr() {
        return this._sender;
    }
    /**
     * Secret key belonging to the signer
     */
    get sk() {
        return this._account.sk;
    }
    /**
     * Transaction signer for the underlying signing account
     */
    get signer() {
        return this._signer;
    }
    /**
     * Algorand account of the sender address and signer private key
     */
    get sender() {
        return {
            addr: this._sender,
            sk: this._account.sk,
        };
    }
    constructor(account, sender) {
        this._account = account;
        this._sender = sender ?? account.addr;
        this._signer = algosdk_1.default.makeBasicAccountTransactionSigner(account);
    }
}
exports.SigningAccount = SigningAccount;
//# sourceMappingURL=account.js.map