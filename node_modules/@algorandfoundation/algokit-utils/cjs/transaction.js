"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAtomicTransactionComposerTransactions = exports.getTransactionParams = exports.controlFees = exports.capTransactionFee = exports.waitForConfirmation = exports.sendGroupOfTransactions = exports.performAtomicTransactionComposerSimulate = exports.performAtomicTransactionComposerDryrun = exports.sendAtomicTransactionComposer = exports.sendTransaction = exports.signTransaction = exports.getSenderTransactionSigner = exports.getTransactionWithSigner = exports.getSenderAddress = exports.encodeTransactionNote = void 0;
const algosdk_1 = __importStar(require("algosdk"));
const buffer_1 = require("buffer");
const _1 = require("./");
const util_1 = require("./util");
/** Encodes a transaction note into a byte array ready to be included in an Algorand transaction.
 *
 * @param note The transaction note
 * @returns the transaction note ready for inclusion in a transaction
 *
 *  Case on the value of `data` this either be:
 *   * `null` | `undefined`: `undefined`
 *   * `string`: The string value
 *   * Uint8Array: passthrough
 *   * Arc2TransactionNote object: ARC-0002 compatible transaction note
 *   * Else: The object/value converted into a JSON string representation
 */
function encodeTransactionNote(note) {
    if (note == null || typeof note === 'undefined') {
        return undefined;
    }
    else if (typeof note === 'object' && note.constructor === Uint8Array) {
        return note;
    }
    else if (typeof note === 'object' && 'dAppName' in note) {
        const arc2Payload = `${note.dAppName}:${note.format}${typeof note.data === 'string' ? note.data : JSON.stringify(note.data)}`;
        const encoder = new TextEncoder();
        return encoder.encode(arc2Payload);
    }
    else {
        const n = typeof note === 'string' ? note : JSON.stringify(note);
        const encoder = new TextEncoder();
        return encoder.encode(n);
    }
}
exports.encodeTransactionNote = encodeTransactionNote;
/**
 * Returns the public address of the given transaction sender.
 * @param sender A transaction sender
 * @returns The public address
 */
const getSenderAddress = function (sender) {
    return 'addr' in sender ? sender.addr : sender.address();
};
exports.getSenderAddress = getSenderAddress;
const memoize = (fn) => {
    const cache = new Map();
    const cached = function (val) {
        return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
    };
    cached.cache = cache;
    return cached;
};
/**
 * Given a transaction in a variety of supported formats, returns a TransactionWithSigner object ready to be passed to an
 * AtomicTransactionComposer's addTransaction method.
 * @param transaction One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the
 * signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by
 * one of algokit utils' helpers (signer is obtained from the defaultSender parameter)
 * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not
 * include a signer.
 * @returns A TransactionWithSigner object.
 */
const getTransactionWithSigner = async (transaction, defaultSender) => {
    if ('txn' in transaction)
        return transaction;
    if (defaultSender === undefined)
        throw new Error('Default sender must be provided when passing in a transaction object that does not contain its own signer');
    return transaction instanceof Promise
        ? {
            txn: (await transaction).transaction,
            signer: (0, exports.getSenderTransactionSigner)(defaultSender),
        }
        : 'transaction' in transaction
            ? {
                txn: transaction.transaction,
                signer: (0, exports.getSenderTransactionSigner)(transaction.signer),
            }
            : {
                txn: transaction,
                signer: (0, exports.getSenderTransactionSigner)(defaultSender),
            };
};
exports.getTransactionWithSigner = getTransactionWithSigner;
/**
 * Returns a `TransactionSigner` for the given transaction sender.
 * This function has memoization, so will return the same transaction signer for a given sender.
 * @param sender A transaction sender
 * @returns A transaction signer
 */
exports.getSenderTransactionSigner = memoize(function (sender) {
    return 'signer' in sender
        ? sender.signer
        : 'lsig' in sender
            ? algosdk_1.default.makeLogicSigAccountTransactionSigner(sender)
            : algosdk_1.default.makeBasicAccountTransactionSigner(sender);
});
/**
 * Signs a single transaction by the given signer.
 * @param transaction The transaction to sign
 * @param signer The signer to sign
 * @returns The signed transaction as a `Uint8Array`
 */
const signTransaction = async (transaction, signer) => {
    return 'sk' in signer
        ? transaction.signTxn(signer.sk)
        : 'lsig' in signer
            ? algosdk_1.default.signLogicSigTransactionObject(transaction, signer).blob
            : 'sign' in signer
                ? signer.sign(transaction)
                : (await signer.signer([transaction], [0]))[0];
};
exports.signTransaction = signTransaction;
/** Prepares a transaction for sending and then (if instructed) signs and sends the given transaction to the chain.
 *
 * @param send The details for the transaction to prepare/send, including:
 *   * `transaction`: The unsigned transaction
 *   * `from`: The account to sign the transaction with: either an account with private key loaded or a logic signature account
 *   * `config`: The sending configuration for this transaction
 * @param algod An algod client
 *
 * @returns An object with transaction (`transaction`) and (if `skipWaiting` is `false` or `undefined`) confirmation (`confirmation`)
 */
const sendTransaction = async function (send, algod) {
    const { transaction, from, sendParams } = send;
    const { skipSending, skipWaiting, fee, maxFee, suppressLog, maxRoundsToWaitForConfirmation, atc } = sendParams ?? {};
    controlFees(transaction, { fee, maxFee });
    if (atc) {
        atc.addTransaction({ txn: transaction, signer: (0, exports.getSenderTransactionSigner)(from) });
        return { transaction };
    }
    if (skipSending) {
        return { transaction };
    }
    const signedTransaction = await (0, exports.signTransaction)(transaction, from);
    await algod.sendRawTransaction(signedTransaction).do();
    _1.Config.getLogger(suppressLog).info(`Sent transaction ID ${transaction.txID()} ${transaction.type} from ${(0, exports.getSenderAddress)(from)}`);
    let confirmation = undefined;
    if (!skipWaiting) {
        confirmation = await (0, exports.waitForConfirmation)(transaction.txID(), maxRoundsToWaitForConfirmation ?? 5, algod);
    }
    return { transaction, confirmation };
};
exports.sendTransaction = sendTransaction;
/**
 * Signs and sends transactions that have been collected by an `AtomicTransactionComposer`.
 * @param atcSend The parameters controlling the send, including:
 *  * `atc` The `AtomicTransactionComposer`
 *  * `sendParams` The parameters to control the send behaviour
 * @param algod An algod client
 * @returns An object with transaction IDs, transactions, group transaction ID (`groupTransactionId`) if more than 1 transaction sent, and (if `skipWaiting` is `false` or unset) confirmation (`confirmation`)
 */
const sendAtomicTransactionComposer = async function (atcSend, algod) {
    const { atc, sendParams } = atcSend;
    const transactionsWithSigner = atc.buildGroup();
    const transactionsToSend = transactionsWithSigner.map((t) => {
        return t.txn;
    });
    let groupId = undefined;
    if (transactionsToSend.length > 1) {
        groupId = transactionsToSend[0].group ? buffer_1.Buffer.from(transactionsToSend[0].group).toString('base64') : '';
        _1.Config.getLogger(sendParams?.suppressLog).info(`Sending group of ${transactionsToSend.length} transactions (${groupId})`, {
            transactionsToSend,
        });
        _1.Config.getLogger(sendParams?.suppressLog).debug(`Transaction IDs (${groupId})`, transactionsToSend.map((t) => t.txID()));
    }
    try {
        const result = await atc.execute(algod, sendParams?.maxRoundsToWaitForConfirmation ?? 5);
        if (transactionsToSend.length > 1) {
            _1.Config.getLogger(sendParams?.suppressLog).info(`Group transaction (${groupId}) sent with ${transactionsToSend.length} transactions`);
        }
        else {
            _1.Config.getLogger(sendParams?.suppressLog).info(`Sent transaction ID ${transactionsToSend[0].txID()} ${transactionsToSend[0].type} from ${algosdk_1.default.encodeAddress(transactionsToSend[0].from.publicKey)}`);
        }
        let confirmations = undefined;
        if (!sendParams?.skipWaiting) {
            confirmations = await Promise.all(transactionsToSend.map(async (t) => algosdk_1.modelsv2.PendingTransactionResponse.from_obj_for_encoding(await algod.pendingTransactionInformation(t.txID()).do())));
        }
        return {
            groupId,
            confirmations,
            txIds: transactionsToSend.map((t) => t.txID()),
            transactions: transactionsToSend,
            returns: result.methodResults.map((r) => ({
                decodeError: r.decodeError,
                returnValue: r.returnValue,
                rawReturnValue: r.rawReturnValue,
            })),
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    catch (e) {
        _1.Config.logger.info('Received error executing Atomic Transaction Composer, for more information enable the debug flag');
        if (_1.Config.debug && typeof e === 'object') {
            e.traces = [];
            _1.Config.logger.debug('Received error executing Atomic Transaction Composer and debug flag enabled; attempting simulation to get more information');
            const simulate = await performAtomicTransactionComposerSimulate(atc, algod);
            if (simulate.txnGroups[0].failedAt) {
                for (const txn of simulate.txnGroups[0].txnResults) {
                    e.traces.push({
                        trace: txn.execTrace?.get_obj_for_encoding(),
                        appBudget: txn.appBudgetConsumed,
                        logicSigBudget: txn.logicSigBudgetConsumed,
                        logs: txn.txnResult.logs,
                        message: simulate.txnGroups[0].failureMessage,
                    });
                }
            }
        }
        throw e;
    }
};
exports.sendAtomicTransactionComposer = sendAtomicTransactionComposer;
/**
 * Performs a dry run of the transactions loaded into the given AtomicTransactionComposer`
 * @param atc The AtomicTransactionComposer` with transaction(s) loaded
 * @param algod An Algod client
 * @returns The dryrun result
 */
async function performAtomicTransactionComposerDryrun(atc, algod) {
    const signedTransactions = await atc.gatherSignatures();
    const txns = signedTransactions.map((t) => {
        return algosdk_1.default.decodeSignedTransaction(t);
    });
    const dryrun = await algosdk_1.default.createDryrun({ client: algod, txns });
    return new algosdk_1.default.DryrunResult(await algod.dryrun(dryrun).do());
}
exports.performAtomicTransactionComposerDryrun = performAtomicTransactionComposerDryrun;
/**
 * Performs a simulation of the transactions loaded into the given AtomicTransactionComposer.
 * @param atc The AtomicTransactionComposer with transaction(s) loaded.
 * @param algod An Algod client to perform the simulation.
 * @returns The simulation result, which includes various details about how the transactions would be processed.
 */
async function performAtomicTransactionComposerSimulate(atc, algod) {
    const unsignedTransactionsSigners = atc.buildGroup();
    const decodedSignedTransactions = unsignedTransactionsSigners.map((ts) => algosdk_1.default.encodeUnsignedSimulateTransaction(ts.txn));
    const simulateRequest = new algosdk_1.modelsv2.SimulateRequest({
        allowEmptySignatures: true,
        allowMoreLogging: true,
        execTraceConfig: new algosdk_1.modelsv2.SimulateTraceConfig({
            enable: true,
            scratchChange: true,
            stackChange: true,
        }),
        txnGroups: [
            new algosdk_1.modelsv2.SimulateRequestTransactionGroup({
                txns: decodedSignedTransactions.map((txn) => algosdk_1.default.decodeObj(txn)),
            }),
        ],
    });
    const simulateResult = await algod.simulateTransactions(simulateRequest).do();
    return simulateResult;
}
exports.performAtomicTransactionComposerSimulate = performAtomicTransactionComposerSimulate;
/**
 * Signs and sends a group of [up to 16](https://developer.algorand.org/docs/get-details/atomic_transfers/#create-transactions) transactions to the chain
 *
 * @param groupSend The group details to send, with:
 *   * `transactions`: The array of transactions to send along with their signing account
 *   * `sendParams`: The parameters to dictate how the group is sent
 * @param algod An algod client
 * @returns An object with transaction IDs, transactions, group transaction ID (`groupTransactionId`) if more than 1 transaction sent, and (if `skipWaiting` is `false` or unset) confirmation (`confirmation`)
 */
const sendGroupOfTransactions = async function (groupSend, algod) {
    const { transactions, signer, sendParams } = groupSend;
    const defaultTransactionSigner = signer ? (0, exports.getSenderTransactionSigner)(signer) : undefined;
    const transactionsWithSigner = await Promise.all(transactions.map(async (t) => {
        if ('signer' in t)
            return {
                txn: t.transaction,
                signer: (0, exports.getSenderTransactionSigner)(t.signer),
                sender: t.signer,
            };
        const txn = 'then' in t ? (await t).transaction : t;
        if (!signer) {
            throw new Error(`Attempt to send transaction ${txn.txID()} as part of a group transaction, but no signer parameter was provided.`);
        }
        return {
            txn,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signer: defaultTransactionSigner,
            sender: signer,
        };
    }));
    const atc = new algosdk_1.AtomicTransactionComposer();
    transactionsWithSigner.forEach((txn) => atc.addTransaction(txn));
    return (await (0, exports.sendAtomicTransactionComposer)({ atc, sendParams }, algod));
};
exports.sendGroupOfTransactions = sendGroupOfTransactions;
/**
 * Wait until the transaction is confirmed or rejected, or until `timeout`
 * number of rounds have passed.
 *
 * @param algod An algod client
 * @param transactionId The transaction ID to wait for
 * @param maxRoundsToWait Maximum number of rounds to wait
 *
 * @return Pending transaction information
 * @throws Throws an error if the transaction is not confirmed or rejected in the next `timeout` rounds
 */
const waitForConfirmation = async function (transactionId, maxRoundsToWait, algod) {
    if (maxRoundsToWait < 0) {
        throw new Error(`Invalid timeout, received ${maxRoundsToWait}, expected > 0`);
    }
    // Get current round
    const status = algosdk_1.modelsv2.NodeStatusResponse.from_obj_for_encoding(await algod.status().do());
    if (status === undefined) {
        throw new Error('Unable to get node status');
    }
    // Loop for up to `timeout` rounds looking for a confirmed transaction
    const startRound = BigInt(status.lastRound) + 1n;
    let currentRound = startRound;
    while (currentRound < startRound + BigInt(maxRoundsToWait)) {
        try {
            const pendingInfo = algosdk_1.modelsv2.PendingTransactionResponse.from_obj_for_encoding(await algod.pendingTransactionInformation(transactionId).do());
            if (pendingInfo !== undefined) {
                const confirmedRound = pendingInfo.confirmedRound;
                if (confirmedRound && confirmedRound > 0) {
                    return pendingInfo;
                }
                else {
                    const poolError = pendingInfo.poolError;
                    if (poolError != null && poolError.length > 0) {
                        // If there was a pool error, then the transaction has been rejected!
                        throw new Error(`Transaction ${transactionId} was rejected; pool error: ${poolError}`);
                    }
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            if (e.name === 'URLTokenBaseHTTPError') {
                currentRound++;
                continue;
            }
        }
        await algod.statusAfterBlock((0, util_1.toNumber)(currentRound)).do();
        currentRound++;
    }
    throw new Error(`Transaction ${transactionId} not confirmed after ${maxRoundsToWait} rounds`);
};
exports.waitForConfirmation = waitForConfirmation;
/**
 * Limit the acceptable fee to a defined amount of µALGOs.
 * This also sets the transaction to be flatFee to ensure the transaction only succeeds at
 * the estimated rate.
 * @param transaction The transaction to cap or suggested params object about to be used to create a transaction
 * @param maxAcceptableFee The maximum acceptable fee to pay
 */
function capTransactionFee(transaction, maxAcceptableFee) {
    // If a flat fee hasn't already been defined
    if (!transaction.flatFee) {
        // Once a transaction has been constructed by algosdk, transaction.fee indicates what the total transaction fee
        // Will be based on the current suggested fee-per-byte value.
        if (transaction.fee > maxAcceptableFee.microAlgos) {
            throw new Error(`Cancelled transaction due to high network congestion fees. Algorand suggested fees would cause this transaction to cost ${transaction.fee} µALGOs. Cap for this transaction is ${maxAcceptableFee.microAlgos} µALGOs.`);
        }
        else if (transaction.fee > algosdk_1.default.ALGORAND_MIN_TX_FEE) {
            _1.Config.logger.warn(`Algorand network congestion fees are in effect. This transaction will incur a fee of ${transaction.fee} µALGOs.`);
        }
        // Now set the flat on the transaction. Otherwise the network may increase the fee above our cap and perform the transaction.
        transaction.flatFee = true;
    }
}
exports.capTransactionFee = capTransactionFee;
/**
 * Allows for control of fees on a `Transaction` or `SuggestedParams` object
 * @param transaction The transaction or suggested params
 * @param feeControl The fee control parameters
 */
function controlFees(transaction, feeControl) {
    const { fee, maxFee } = feeControl;
    if (fee) {
        transaction.fee = fee.microAlgos;
        transaction.flatFee = true;
    }
    if (maxFee !== undefined) {
        capTransactionFee(transaction, maxFee);
    }
    return transaction;
}
exports.controlFees = controlFees;
/**
 * Returns suggested transaction parameters from algod unless some are already provided.
 * @param params Optionally provide parameters to use
 * @param algod Algod algod
 * @returns The suggested transaction parameters
 */
async function getTransactionParams(params, algod) {
    return params ? { ...params } : await algod.getTransactionParams().do();
}
exports.getTransactionParams = getTransactionParams;
/**
 * Returns the array of transactions currently present in the given `AtomicTransactionComposer`
 * @param atc The atomic transaction composer
 * @returns The array of transactions with signers
 */
function getAtomicTransactionComposerTransactions(atc) {
    try {
        return atc.clone().buildGroup();
    }
    catch {
        return [];
    }
}
exports.getAtomicTransactionComposerTransactions = getAtomicTransactionComposerTransactions;
//# sourceMappingURL=transaction.js.map