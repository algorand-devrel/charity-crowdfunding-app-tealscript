"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getABIMethodSignature = exports.compileTeal = exports.getAppById = exports.getBoxReference = exports.getAppArgsForABICall = exports.getAppArgsForTransaction = exports.decodeAppState = exports.getAppBoxValuesFromABIType = exports.getAppBoxValueFromABIType = exports.getAppBoxValues = exports.getAppBoxValue = exports.getAppBoxNames = exports.getAppLocalState = exports.getAppGlobalState = exports.getABIReturn = exports.callApp = exports.getAppOnCompleteAction = exports.updateApp = exports.createApp = void 0;
const algosdk_1 = __importStar(require("algosdk"));
const buffer_1 = require("buffer");
const _1 = require("./");
const transaction_1 = require("./transaction");
const app_1 = require("./types/app");
const util_1 = require("./util");
/**
 * Creates a smart contract app, returns the details of the created app.
 * @param create The parameters to create the app with
 * @param algod An algod client
 * @returns The details of the created app, or the transaction to create it if `skipSending` and the compilation result
 */
async function createApp(create, algod) {
    const { from, approvalProgram: approval, clearStateProgram: clear, schema, note, transactionParams, args, onCompleteAction, ...sendParams } = create;
    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;
    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;
    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;
    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;
    if (args && args.method) {
        const atc = attachATC(sendParams);
        const before = (0, transaction_1.getAtomicTransactionComposerTransactions)(atc);
        atc.addMethodCall({
            appID: 0,
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            numLocalInts: schema.localInts,
            numLocalByteSlices: schema.localByteSlices,
            numGlobalInts: schema.globalInts,
            numGlobalByteSlices: schema.globalByteSlices,
            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / app_1.APP_PAGE_MAX_SIZE),
            onComplete: getAppOnCompleteAction(onCompleteAction),
            suggestedParams: (0, transaction_1.controlFees)(await (0, transaction_1.getTransactionParams)(transactionParams, algod), sendParams),
            note: (0, transaction_1.encodeTransactionNote)(note),
            ...(await getAppArgsForABICall(args, from)),
        });
        if (sendParams.skipSending) {
            const after = atc.clone().buildGroup();
            return {
                transaction: after[after.length - 1].txn,
                transactions: after.slice(before.length).map((t) => t.txn),
                appId: 0,
                appAddress: '',
                compiledApproval,
                compiledClear,
            };
        }
        const result = await (0, transaction_1.sendAtomicTransactionComposer)({ atc, sendParams }, algod);
        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;
        if (confirmation) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const appId = confirmation.applicationIndex;
            _1.Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${(0, transaction_1.getSenderAddress)(from)}`);
            return {
                transactions: result.transactions,
                confirmations: result.confirmations,
                return: confirmation ? getABIReturn(args, confirmation) : undefined,
                transaction: result.transactions[result.transactions.length - 1],
                confirmation: confirmation,
                appId,
                appAddress: algosdk_1.default.getApplicationAddress(appId),
                compiledApproval,
                compiledClear,
            };
        }
        else {
            return {
                transactions: result.transactions,
                confirmations: result.confirmations,
                return: confirmation ? getABIReturn(args, confirmation) : undefined,
                transaction: result.transactions[result.transactions.length - 1],
                confirmation: confirmation,
                appId: 0,
                appAddress: '',
                compiledApproval,
                compiledClear,
            };
        }
    }
    else {
        const transaction = algosdk_1.default.makeApplicationCreateTxnFromObject({
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            numLocalInts: schema.localInts,
            numLocalByteSlices: schema.localByteSlices,
            numGlobalInts: schema.globalInts,
            numGlobalByteSlices: schema.globalByteSlices,
            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / app_1.APP_PAGE_MAX_SIZE),
            onComplete: getAppOnCompleteAction(onCompleteAction),
            suggestedParams: await (0, transaction_1.getTransactionParams)(transactionParams, algod),
            from: (0, transaction_1.getSenderAddress)(from),
            note: (0, transaction_1.encodeTransactionNote)(note),
            ...getAppArgsForTransaction(args),
            rekeyTo: undefined,
        });
        const { confirmation } = await (0, transaction_1.sendTransaction)({ transaction, from, sendParams }, algod);
        if (confirmation) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const appId = confirmation.applicationIndex;
            _1.Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${(0, transaction_1.getSenderAddress)(from)}`);
            return {
                transaction,
                transactions: [transaction],
                confirmation,
                confirmations: confirmation ? [confirmation] : undefined,
                appId,
                appAddress: algosdk_1.default.getApplicationAddress(appId),
                return: getABIReturn(args, confirmation),
                compiledApproval,
                compiledClear,
            };
        }
        else {
            return { transaction, transactions: [transaction], appId: 0, appAddress: '', compiledApproval, compiledClear };
        }
    }
}
exports.createApp = createApp;
/**
 * Updates a smart contract app.
 * @param update The parameters to update the app with
 * @param algod An algod client
 * @returns The transaction send result and the compilation result
 */
async function updateApp(update, algod) {
    const { appId, from, approvalProgram: approval, clearStateProgram: clear, note, transactionParams, args, ...sendParams } = update;
    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;
    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;
    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;
    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;
    _1.Config.getLogger(sendParams.suppressLog).debug(`Updating app ${appId}`);
    if (args && args.method) {
        const atc = attachATC(sendParams);
        const before = (0, transaction_1.getAtomicTransactionComposerTransactions)(atc);
        atc.addMethodCall({
            appID: (0, util_1.toNumber)(appId),
            onComplete: algosdk_1.OnApplicationComplete.UpdateApplicationOC,
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            suggestedParams: (0, transaction_1.controlFees)(await (0, transaction_1.getTransactionParams)(transactionParams, algod), sendParams),
            note: (0, transaction_1.encodeTransactionNote)(note),
            ...(await getAppArgsForABICall(args, from)),
        });
        if (sendParams.skipSending) {
            const after = atc.clone().buildGroup();
            return {
                transaction: after[after.length - 1].txn,
                transactions: after.slice(before.length).map((t) => t.txn),
            };
        }
        const result = await (0, transaction_1.sendAtomicTransactionComposer)({ atc, sendParams }, algod);
        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;
        return {
            transactions: result.transactions,
            confirmations: result.confirmations,
            return: confirmation ? getABIReturn(args, confirmation) : undefined,
            transaction: result.transactions[result.transactions.length - 1],
            confirmation: confirmation,
        };
    }
    else {
        const transaction = algosdk_1.default.makeApplicationUpdateTxnFromObject({
            appIndex: (0, util_1.toNumber)(appId),
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            suggestedParams: await (0, transaction_1.getTransactionParams)(transactionParams, algod),
            from: (0, transaction_1.getSenderAddress)(from),
            note: (0, transaction_1.encodeTransactionNote)(note),
            ...getAppArgsForTransaction(args),
            rekeyTo: undefined,
        });
        const result = await (0, transaction_1.sendTransaction)({ transaction, from, sendParams }, algod);
        return {
            ...result,
            transactions: [result.transaction],
            confirmations: result.confirmation ? [result.confirmation] : undefined,
            return: getABIReturn(args, result.confirmation),
            compiledApproval,
            compiledClear,
        };
    }
}
exports.updateApp = updateApp;
function attachATC(sendParams) {
    if (sendParams.atc) {
        sendParams.skipSending = true;
    }
    sendParams.atc = sendParams.atc ?? new algosdk_1.AtomicTransactionComposer();
    return sendParams.atc;
}
/** Returns an `algosdk.OnApplicationComplete` for the given onCompleteAction.
 *
 * If given `undefined` will return `OnApplicationComplete.NoOpOC`.
 *
 * If given an `AppCallType` will convert the string enum to the correct underlying `algosdk.OnApplicationComplete`.
 *
 * @param onCompletionAction The on completion action
 * @returns The `algosdk.OnApplicationComplete`
 */
function getAppOnCompleteAction(onCompletionAction) {
    switch (onCompletionAction) {
        case undefined:
        case 'no_op':
        case algosdk_1.OnApplicationComplete.NoOpOC:
            return algosdk_1.OnApplicationComplete.NoOpOC;
        case 'opt_in':
        case algosdk_1.OnApplicationComplete.OptInOC:
            return algosdk_1.OnApplicationComplete.OptInOC;
        case 'close_out':
        case algosdk_1.OnApplicationComplete.CloseOutOC:
            return algosdk_1.OnApplicationComplete.CloseOutOC;
        case 'clear_state':
        case algosdk_1.OnApplicationComplete.ClearStateOC:
            return algosdk_1.OnApplicationComplete.ClearStateOC;
        case 'update_application':
        case algosdk_1.OnApplicationComplete.UpdateApplicationOC:
            return algosdk_1.OnApplicationComplete.UpdateApplicationOC;
        case 'delete_application':
        case algosdk_1.OnApplicationComplete.DeleteApplicationOC:
            return algosdk_1.OnApplicationComplete.DeleteApplicationOC;
    }
}
exports.getAppOnCompleteAction = getAppOnCompleteAction;
/**
 * Issues a call to a given app.
 * @param call The call details.
 * @param algod An algod client
 * @returns The result of the call
 */
async function callApp(call, algod) {
    const { appId, callType, from, args, note, transactionParams, ...sendParams } = call;
    if (args && args.method) {
        const atc = attachATC(sendParams);
        const before = (0, transaction_1.getAtomicTransactionComposerTransactions)(atc);
        atc.addMethodCall({
            appID: (0, util_1.toNumber)(appId),
            suggestedParams: (0, transaction_1.controlFees)(await (0, transaction_1.getTransactionParams)(transactionParams, algod), sendParams),
            note: (0, transaction_1.encodeTransactionNote)(note),
            onComplete: getAppOnCompleteAction(callType),
            ...(await getAppArgsForABICall(args, from)),
        });
        if (sendParams.skipSending) {
            const after = atc.clone().buildGroup();
            return {
                transaction: after[after.length - 1].txn,
                transactions: after.slice(before.length).map((t) => t.txn),
            };
        }
        const result = await (0, transaction_1.sendAtomicTransactionComposer)({ atc, sendParams }, algod);
        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;
        return {
            transactions: result.transactions,
            confirmations: result.confirmations,
            return: confirmation ? getABIReturn(args, confirmation) : undefined,
            transaction: result.transactions[result.transactions.length - 1],
            confirmation: confirmation,
        };
    }
    const appCallParams = {
        appIndex: (0, util_1.toNumber)(appId),
        from: (0, transaction_1.getSenderAddress)(from),
        suggestedParams: await (0, transaction_1.getTransactionParams)(transactionParams, algod),
        ...getAppArgsForTransaction(args),
        note: (0, transaction_1.encodeTransactionNote)(note),
        rekeyTo: undefined,
    };
    let transaction;
    switch (getAppOnCompleteAction(callType)) {
        case algosdk_1.OnApplicationComplete.OptInOC:
            transaction = algosdk_1.default.makeApplicationOptInTxnFromObject(appCallParams);
            break;
        case algosdk_1.OnApplicationComplete.ClearStateOC:
            transaction = algosdk_1.default.makeApplicationClearStateTxnFromObject(appCallParams);
            break;
        case algosdk_1.OnApplicationComplete.CloseOutOC:
            transaction = algosdk_1.default.makeApplicationCloseOutTxnFromObject(appCallParams);
            break;
        case algosdk_1.OnApplicationComplete.DeleteApplicationOC:
            transaction = algosdk_1.default.makeApplicationDeleteTxnFromObject(appCallParams);
            break;
        case algosdk_1.OnApplicationComplete.NoOpOC:
            transaction = algosdk_1.default.makeApplicationNoOpTxnFromObject(appCallParams);
            break;
        default:
            throw new Error(`Received unexpected call type ${callType}`);
    }
    const result = await (0, transaction_1.sendTransaction)({ transaction, from, sendParams }, algod);
    return {
        ...result,
        transactions: [result.transaction],
        confirmations: result.confirmation ? [result.confirmation] : undefined,
        return: getABIReturn(args, result.confirmation),
    };
}
exports.callApp = callApp;
/**
 * Returns any ABI return values for the given app call arguments and transaction confirmation.
 * @param args The arguments that were used for the call
 * @param confirmation The transaction confirmation from algod
 * @returns The return value for the method call
 */
function getABIReturn(args, confirmation) {
    if (!args || !args.method) {
        return undefined;
    }
    const method = 'txnCount' in args.method ? args.method : new algosdk_1.ABIMethod(args.method);
    if (method.returns.type !== 'void' && confirmation) {
        // The parseMethodResponse method mutates the second parameter :(
        const resultDummy = {
            txID: '',
            method,
            rawReturnValue: new Uint8Array(),
        };
        const response = algosdk_1.AtomicTransactionComposer.parseMethodResponse(method, resultDummy, confirmation);
        return !response.decodeError
            ? {
                rawReturnValue: response.rawReturnValue,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                returnValue: response.returnValue,
                decodeError: undefined,
            }
            : {
                rawReturnValue: undefined,
                returnValue: undefined,
                decodeError: response.decodeError,
            };
    }
    return undefined;
}
exports.getABIReturn = getABIReturn;
/**
 * Returns the current global state values for the given app ID
 * @param appId The ID of the app return global state for
 * @param algod An algod client instance
 * @returns The current global state
 */
async function getAppGlobalState(appId, algod) {
    const appInfo = await getAppById(appId, algod);
    if (!appInfo.params || !appInfo.params.globalState) {
        throw new Error("Couldn't find global state");
    }
    return decodeAppState(appInfo.params.globalState);
}
exports.getAppGlobalState = getAppGlobalState;
/**
 * Returns the current global state values for the given app ID and account
 * @param appId The ID of the app return global state for
 * @param account Either the string address of an account or an account object for the account to get local state for the given app
 * @param algod An algod client instance
 * @returns The current local state for the given (app, account) combination
 */
async function getAppLocalState(appId, account, algod) {
    const accountAddress = typeof account === 'string' ? account : (0, transaction_1.getSenderAddress)(account);
    const appInfo = algosdk_1.modelsv2.AccountApplicationResponse.from_obj_for_encoding(await algod.accountApplicationInformation(accountAddress, (0, util_1.toNumber)(appId)).do());
    if (!appInfo.appLocalState?.keyValue) {
        throw new Error("Couldn't find local state");
    }
    return decodeAppState(appInfo.appLocalState.keyValue);
}
exports.getAppLocalState = getAppLocalState;
/**
 * Returns the names of the boxes for the given app.
 * @param appId The ID of the app return box names for
 * @param algod An algod client instance
 * @returns The current box names
 */
async function getAppBoxNames(appId, algod) {
    const boxResult = await algod.getApplicationBoxes((0, util_1.toNumber)(appId)).do();
    return boxResult.boxes.map((b) => {
        return {
            nameRaw: b.name,
            nameBase64: buffer_1.Buffer.from(b.name).toString('base64'),
            name: buffer_1.Buffer.from(b.name).toString('utf-8'),
        };
    });
}
exports.getAppBoxNames = getAppBoxNames;
/**
 * Returns the value of the given box name for the given app.
 * @param appId The ID of the app return box names for
 * @param boxName The name of the box to return either as a string, binary array or `BoxName`
 * @param algod An algod client instance
 * @returns The current box value as a byte array
 */
async function getAppBoxValue(appId, boxName, algod) {
    const name = typeof boxName === 'string' ? new Uint8Array(buffer_1.Buffer.from(boxName, 'utf-8')) : 'name' in boxName ? boxName.nameRaw : boxName;
    const boxResult = await algod.getApplicationBoxByName((0, util_1.toNumber)(appId), name).do();
    return boxResult.value;
}
exports.getAppBoxValue = getAppBoxValue;
/**
 * Returns the value of the given box names for the given app.
 * @param appId The ID of the app return box names for
 * @param boxNames The names of the boxes to return either as a string, binary array or `BoxName`
 * @param algod An algod client instance
 * @returns The current box values as a byte array in the same order as the passed in box names
 */
async function getAppBoxValues(appId, boxNames, algod) {
    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValue(appId, boxName, algod)));
}
exports.getAppBoxValues = getAppBoxValues;
/**
 * Returns the value of the given box name for the given app decoded based on the given ABI type.
 * @param request The parameters for the box value request
 * @param algod An algod client instance
 * @returns The current box value as an ABI value
 */
async function getAppBoxValueFromABIType(request, algod) {
    const { appId, boxName, type } = request;
    const value = await getAppBoxValue(appId, boxName, algod);
    return type.decode(value);
}
exports.getAppBoxValueFromABIType = getAppBoxValueFromABIType;
/**
 * Returns the value of the given box names for the given app decoded based on the given ABI type.
 * @param request The parameters for the box value request
 * @param algod An algod client instance
 * @returns The current box values as an ABI value in the same order as the passed in box names
 */
async function getAppBoxValuesFromABIType(request, algod) {
    const { appId, boxNames, type } = request;
    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValueFromABIType({ appId, boxName, type }, algod)));
}
exports.getAppBoxValuesFromABIType = getAppBoxValuesFromABIType;
/**
 * Converts an array of global/local state values from the algod api to a more friendly
 * generic object keyed by the UTF-8 value of the key.
 * @param state A `global-state`, `local-state`, `global-state-deltas` or `local-state-deltas`
 * @returns An object keyeed by the UTF-8 representation of the key with various parsings of the values
 */
function decodeAppState(state) {
    const stateValues = {};
    // Start with empty set
    for (const stateVal of state) {
        const keyBase64 = stateVal.key;
        const keyRaw = buffer_1.Buffer.from(keyBase64, 'base64');
        const key = keyRaw.toString('utf-8');
        const tealValue = stateVal.value;
        const dataTypeFlag = 'action' in tealValue ? tealValue.action : tealValue.type;
        let valueBase64;
        let valueRaw;
        switch (dataTypeFlag) {
            case 1:
                valueBase64 = tealValue.bytes ?? '';
                valueRaw = buffer_1.Buffer.from(valueBase64, 'base64');
                stateValues[key] = {
                    keyRaw,
                    keyBase64,
                    valueRaw: new Uint8Array(valueRaw),
                    valueBase64: valueBase64,
                    value: valueRaw.toString('utf-8'),
                };
                break;
            case 2: {
                const value = tealValue.uint ?? 0;
                stateValues[key] = {
                    keyRaw,
                    keyBase64,
                    value,
                };
                break;
            }
            default:
                throw new Error(`Received unknown state data type of ${dataTypeFlag}`);
        }
    }
    return stateValues;
}
exports.decodeAppState = decodeAppState;
/**
 * Returns the app args ready to load onto an app `Transaction` object
 * @param args The app call args
 * @returns The args ready to load into a `Transaction`
 */
function getAppArgsForTransaction(args) {
    if (!args)
        return undefined;
    const encoder = new TextEncoder();
    return {
        accounts: args?.accounts?.map(_getAccountAddress),
        appArgs: args?.appArgs?.map((a) => (typeof a === 'string' ? encoder.encode(a) : a)),
        boxes: args.boxes?.map(getBoxReference),
        foreignApps: args?.apps,
        foreignAssets: args?.assets,
        lease: typeof args?.lease === 'string' ? encoder.encode(args?.lease) : args?.lease,
    };
}
exports.getAppArgsForTransaction = getAppArgsForTransaction;
/**
 * Returns the app args ready to load onto an ABI method call in `AtomicTransactionComposer`
 * @param args The ABI app call args
 * @param from The transaction signer
 * @returns The parameters ready to pass into `addMethodCall` within AtomicTransactionComposer
 */
async function getAppArgsForABICall(args, from) {
    const encoder = new TextEncoder();
    const signer = (0, transaction_1.getSenderTransactionSigner)(from);
    const methodArgs = await Promise.all(('methodArgs' in args ? args.methodArgs : args)?.map(async (a, index) => {
        if (a === undefined) {
            throw new Error(`Argument at position ${index} does not have a value`);
        }
        if (typeof a !== 'object') {
            return a;
        }
        // Handle the various forms of transactions to wrangle them for ATC
        return 'txn' in a
            ? a
            : a instanceof Promise
                ? { txn: (await a).transaction, signer }
                : 'transaction' in a
                    ? { txn: a.transaction, signer }
                    : 'txID' in a
                        ? { txn: a, signer }
                        : a;
    }));
    return {
        method: 'txnCount' in args.method ? args.method : new algosdk_1.ABIMethod(args.method),
        sender: (0, transaction_1.getSenderAddress)(from),
        signer: signer,
        boxes: args.boxes?.map(getBoxReference),
        lease: typeof args.lease === 'string' ? encoder.encode(args.lease) : args.lease,
        appForeignApps: args.apps,
        appForeignAssets: args.assets,
        appAccounts: args.accounts?.map(_getAccountAddress),
        methodArgs: methodArgs,
        rekeyTo: undefined,
    };
}
exports.getAppArgsForABICall = getAppArgsForABICall;
/**
 * Returns a `algosdk.BoxReference` given a `BoxIdentifier` or `BoxReference`.
 * @param box The box to return a reference for
 * @returns The box reference ready to pass into a `Transaction`
 */
function getBoxReference(box) {
    const encoder = new TextEncoder();
    if (typeof box === 'object' && 'appIndex' in box) {
        return box;
    }
    const ref = typeof box === 'object' && 'appId' in box ? box : { appId: 0, name: box };
    return {
        appIndex: ref.appId,
        name: typeof ref.name === 'string'
            ? encoder.encode(ref.name)
            : 'length' in ref.name
                ? ref.name
                : algosdk_1.default.decodeAddress((0, transaction_1.getSenderAddress)(ref.name)).publicKey,
    };
}
exports.getBoxReference = getBoxReference;
function _getAccountAddress(account) {
    return typeof account === 'string' ? account : algosdk_1.default.encodeAddress(account.publicKey);
}
/**
 * Gets the current data for the given app from algod.
 *
 * @param appId The id of the app
 * @param algod An algod client
 * @returns The data about the app
 */
async function getAppById(appId, algod) {
    return algosdk_1.modelsv2.Application.from_obj_for_encoding(await algod.getApplicationByID((0, util_1.toNumber)(appId)).do());
}
exports.getAppById = getAppById;
/**
 * Compiles the given TEAL using algod and returns the result, including source map.
 *
 * @param algod An algod client
 * @param tealCode The TEAL code
 * @returns The information about the compiled file
 */
async function compileTeal(tealCode, algod) {
    const compiled = await algod.compile(tealCode).sourcemap(true).do();
    return {
        teal: tealCode,
        compiled: compiled.result,
        compiledHash: compiled.hash,
        compiledBase64ToBytes: new Uint8Array(buffer_1.Buffer.from(compiled.result, 'base64')),
        sourceMap: new algosdk_1.SourceMap(compiled['sourcemap']),
    };
}
exports.compileTeal = compileTeal;
/**
 * Returns the encoded ABI spec for a given ABI Method
 * @param method The method to return a signature for
 * @returns The encoded ABI method spec e.g. `method_name(uint64,string)string`
 */
const getABIMethodSignature = (method) => {
    return 'getSignature' in method ? method.getSignature() : new algosdk_1.ABIMethod(method).getSignature();
};
exports.getABIMethodSignature = getABIMethodSignature;
//# sourceMappingURL=app.js.map