import ts from 'typescript';
export type CompilerOptions = {
    filename?: string;
    disableWarnings?: boolean;
    algodServer?: string;
    algodToken?: string;
    algodPort?: number;
    disableOverflowChecks?: boolean;
    disableTypeScript?: boolean;
};
export type SourceInfo = {
    filename: string;
    start: ts.LineAndCharacter;
    end: ts.LineAndCharacter;
};
interface ABIMethod {
    name: string;
    readonly?: boolean;
    desc: string;
    args: {
        name: string;
        type: string;
        desc: string;
    }[];
    returns: {
        type: string;
        desc: string;
    };
}
type NodeAndTEAL = {
    node: ts.Node;
    teal: string;
};
/** @internal */
export default class Compiler {
    static diagsRan: string[];
    private currentProgram;
    teal: {
        approval: NodeAndTEAL[];
        clear: NodeAndTEAL[];
        lsig: NodeAndTEAL[];
    };
    generatedTeal: string;
    generatedClearTeal: string;
    private frameInfo;
    private lastNode;
    private mapKeyTypes;
    private classNode;
    srcMap: {
        source: number;
        teal: number;
        pc?: number[];
    }[];
    private customTypes;
    private frameIndex;
    private frameSize;
    private subroutines;
    private clearStateCompiled;
    private ifCount;
    private ternaryCount;
    private whileCount;
    private forCount;
    filename: string;
    content: string;
    private processErrorNodes;
    private frame;
    private currentSubroutine;
    private bareCallConfig;
    abi: {
        name: string;
        desc: string;
        methods: ABIMethod[];
    };
    private storageProps;
    private lastType;
    private contractClasses;
    private lsigClasses;
    name: string;
    pcToLine: {
        [key: number]: number;
    };
    lineToPc: {
        [key: number]: number[];
    };
    private lastSourceCommentRange;
    private comments;
    private typeHint?;
    private constants;
    private readonly OP_PARAMS;
    /** Verifies ABI types are properly decoded for runtime usage */
    private checkDecoding;
    /** Handle any action related to boxes or local/global state */
    private handleStorageAction;
    private andCount;
    private orCount;
    private sourceFile;
    private nodeDepth;
    /**
       The current top level node being processed within a class
  
      This is used to determine if a function call should return a value or not. For example,
  
      ```ts
      class Foo {
        bar(arr: number[]) {
          const x = arr.pop(); // "arr.pop()" is NOT top-level node
          arr.pop(); // "arr.pop()" is top-level node
        }
      }
      ```
     */
    private topLevelNode;
    private multiplyWideRatioFactors;
    private customProperties;
    private customMethods;
    private disableWarnings;
    private algodServer;
    private algodPort;
    private algodToken;
    private disableOverflowChecks;
    private disableTypeScript;
    private tealscriptImport;
    private events;
    constructor(content: string, className: string, options?: CompilerOptions);
    static compileAll(content: string, options: CompilerOptions): Promise<Compiler>[];
    getOpParamObjects(op: string): {
        name: string;
        args: number;
        fn: (node: ts.Node) => void;
    }[];
    private isDynamicType;
    private getTypeLength;
    private getStaticArrayLength;
    private getABIType;
    private getABITupleString;
    private getObjectTypes;
    private postProcessTeal;
    private getTypeScriptDiagnostics;
    compile(): Promise<void>;
    private push;
    private pushVoid;
    private getSignature;
    private pushMethod;
    private routeAbiMethods;
    private maybeValue;
    private hasMaybeValue;
    private pushComments;
    private processThrowStatement;
    private processWhileStatement;
    private processForStatement;
    /**
     * Every node in the AST is passed through this function.
     */
    private processNode;
    private processObjectLiteralExpression;
    private processConditionalExpression;
    private pushLines;
    private getarrayElementTypes;
    private processBools;
    private processTuple;
    private checkEncoding;
    private getTupleElement;
    private processArrayElements;
    private processArrayLiteralExpression;
    /**
     *
     * @param node The top level node to process
     * @param chain The existing expression chain to add to
     * @returns The base expression and reversed expression chain `this.txn.sender` ->
     * `{ chain: [this.txn, this.txn.sender], base: [this] }`
     */
    private getExpressionChain;
    private getAccessChain;
    private processFrame;
    private isArrayType;
    private updateValue;
    private compilerSubroutines;
    private getElementHead;
    private processLiteralStaticTupleAccess;
    private processParentArrayAccess;
    private processMethodDefinition;
    private processClassDeclaration;
    private processBlockStatement;
    private processReturnStatement;
    private fixBitWidth;
    private getStackTypeAfterFunction;
    private getStackTypeFromNode;
    private typeComparison;
    private processBinaryExpression;
    private processLogicalExpression;
    private processIdentifier;
    private processNewExpression;
    private processTypeCast;
    private processVariableDeclaration;
    private initializeStorageFrame;
    private processVariableDeclarator;
    private processExpressionStatement;
    private isDynamicArrayOfStaticType;
    private processIfStatement;
    private processUnaryExpression;
    private processPropertyDefinition;
    private processLiteral;
    /**
     * Method for handling an expression chain that starts with `this`
     *
     * Note this method will delete elements from the chain as they are processed
     *
     * @param chain Expression chain to process
     * @param hasNewValue Whether the chain is being processed as part of an assignment
     */
    private processThisBase;
    /**
     * Walks an expression chain and processes each node
     * @param node The node to process
     * @param newValue If we are setting the value of an array, the new value will be passed here
     */
    private processExpressionChain;
    private processSubroutine;
    private processClearState;
    private processRoutableMethod;
    private processOpcode;
    private processTransaction;
    private processOpcodeImmediate;
    algodCompile(): Promise<void>;
    algodCompileProgram(program: 'approval' | 'clear' | 'lsig'): Promise<{
        result: string;
        hash: string;
    }>;
    private addSourceComment;
    appSpec(): any;
    prettyTeal(teal: NodeAndTEAL[]): NodeAndTEAL[];
}
export {};
